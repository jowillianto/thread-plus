module;
#include <sys/wait.h>
#include <atomic>
#include <cassert>
#include <csignal>
#include <expected>
#include <initializer_list>
#include <iterator>
#include <ranges>
#include <spawn.h>
#include <string_view>
#include <system_error>
#include <vector>
export module thread_plus:process;

namespace thread_plus::process {
  export struct ProcessResult {
    /*
      Returns the status obtained from the subprocess. This is a status set directly by the OS
      specific API.
    */
    int status() const {
      return _status;
    }
    bool is_exit_normal() const {
      return WIFEXITED(_status);
    }
    bool is_terminated() const {
      return WIFSIGNALED(_status);
    }
    bool is_stopped() const {
      return WIFSTOPPED(_status);
    }
    /*
      Returns the exit code of the subprocess. If the process exits normally returns the exit status
      otherwise will return the signal terminating the process.
    */
    int exit_code() const {
      if (WIFEXITED(_status)) return WEXITSTATUS(_status);
      else if (WIFSIGNALED(_status))
        return WTERMSIG(_status);
      else if (WIFSTOPPED(_status))
        return WSTOPSIG(_status);
    }

  private:
    int _status;

    ProcessResult(int status) : _status{status} {}
    friend struct Process;
  };

  export enum class ProcessStatus {
    RUNNING, WAITING, WAITING_DONE
  };

  /*
    A RAII based subprocess running that will release resources on exit, this will be done by
    either waiting on the process or killing the process. Not a threadsafe class, do not call
    modifying functions from two threads.
  */
  export struct Process {
    /*
      @param arguments : this is a specialization so that the constructor can be called by itself
      without using std::array constructor, i.e. using initializer list.
    */
    template <typename... Args>
    Process(std::initializer_list<std::string_view> arguments, Args &&...args) :
      Process(
        std::ranges::subrange{arguments.begin(), arguments.end()}, std::forward<Args>(args)...
      ) {}
    /*
      @param arguments : the first argument is the path to the file followed by the argument.
    */
    template <std::ranges::contiguous_range Container>
      requires(std::same_as<std::ranges::range_value_t<Container>, std::string_view>)
    Process(const Container &arguments, int stdout = 0, int stdin = 1, int stderr = 2) {
      /* Assert that arguments is not empty */
      assert(!std::ranges::empty(arguments));
      // Spawn process.
      _initialize_pre_spawn_file_action(stdout, stdin, stderr);
      _initialize_pre_spawn_attributes();
      _spawn_subprocess(
        *std::ranges::cbegin(arguments),
        std::ranges::subrange{std::ranges::cbegin(arguments) + 1, std::ranges::cend(arguments)}
      );
    }
    /*
      Create a process with spawn attributes given previously.
      @param arguments : the first argument is the path to the file followed by the argument.
    */
    template <std::ranges::contiguous_range Container>
      requires(std::same_as<std::ranges::range_value_t<Container>, std::string_view>)
    Process(
      const Container &arguments,
      posix_spawn_file_actions_t spawn_action,
      posix_spawnattr_t spawn_attributes
    ) :
      _spawn_action{std::move(spawn_action)},
      _spawn_attributes{std::move(spawn_attributes)} {
      /* Assert that arguments is not empty */
      assert(!std::ranges::empty(arguments));
      // Spawn process.
      _spawn_subprocess(
        *std::ranges::cbegin(arguments),
        std::ranges::subrange{std::ranges::cbegin(arguments) + 1, std::ranges::cend(arguments)}
      );
      _status = ProcessStatus::RUNNING;
    }

    /*
      If the process is not running, this will throw std::system_error
    */
    void send_signal(int sig_num) const {
      if (::kill(_pid, sig_num) == -1) throw std::system_error{errno, std::generic_category()};
    }
    /*
      wait for the child in a non blocking manner. This call will modify the process object.
    */
    std::optional<std::expected<ProcessResult, std::system_error>> wait_non_blocking() noexcept {
      _status = ProcessStatus::WAITING;
      int status = 0;
      int wait_status = waitpid(_pid, &status, WNOHANG);
      // Fail called
      if (wait_status == -1)
        return std::unexpected{std::system_error{errno, std::generic_category()}};
      // Process has not changed state
      else if (wait_status == 0)
        return std::nullopt;
      // Process has changed state
      else {
        _status = ProcessStatus::WAITING_DONE;
        return ProcessResult{status};
      }
    }
    /*
      waits for the child to finish execution and finish
    */
    std::expected<ProcessResult, std::system_error> wait() {
      _status = ProcessStatus::WAITING;
      int status = 0;
      int wait_status = waitpid(_pid, &status, 0);
      if (wait_status == -1)
        return std::unexpected { std::system_error{ errno, std::generic_category()}};
      else {
        _status = ProcessStatus::WAITING_DONE;
        return ProcessResult { status };
      }
    }

    void kill() {

    }

    /*
      Returns if the current process is waitable. Takes an additional argument that specifies the 
      memory order for checking.
    */
    bool waitable() const {
      return _status != ProcessStatus::WAITING_DONE;
    }

    ~Process() {
      /*
        We have to kill over here because calling wait() can cause a process to wait indefinitely
        without killing if the child runs indefinitely. In order to prevent such a case from
        happening. A RAII class has to kill the child.
      */
      if (waitable()) {
        kill();
        auto _ = wait();
      }
    }

    /*
      Returns the pid for the process.
    */
    const pid_t &pid() const {
      return _pid;
    }

  private:
    pid_t _pid;
    posix_spawn_file_actions_t _spawn_action;
    posix_spawnattr_t _spawn_attributes;
    ProcessStatus _status;
    std::optional<ProcessResult> _result;
    /*
      Initializes _spawn_action based on the input stdout, stdin, stderr
    */
    void _initialize_pre_spawn_file_action(int stdout, int stdin, int stderr) {
      if (posix_spawn_file_actions_init(&_spawn_action) == -1) {
        throw std::system_error{errno, std::generic_category()};
      }
      if (posix_spawn_file_actions_adddup2(&_spawn_action, stdout, 0) == -1) {
        throw std::system_error{errno, std::generic_category()};
      }
      if (posix_spawn_file_actions_adddup2(&_spawn_action, stdin, 1) == -1) {
        throw std::system_error{errno, std::generic_category()};
      }
      if (posix_spawn_file_actions_adddup2(&_spawn_action, stderr, 2) == -1) {
        throw std::system_error{errno, std::generic_category()};
      }
    }
    /*
      Initializes spawn attributes
    */
    void _initialize_pre_spawn_attributes() {
      posix_spawnattr_init(&_spawn_attributes);
    }

    /*
      Creates a vector container the arguments for a given arguments set in a container satisfying
      the ranges concept
    */
    template <std::ranges::range Container>
      requires(std::same_as<std::ranges::range_value_t<Container>, std::string_view>)
    std::vector<const char *> _make_argv(const Container &arguments) {
      std::vector<const char *> container;
      container.reserve(std::ranges::size(arguments) + 1);
      std::ranges::copy(
        arguments |
          std::ranges::views::transform([](const std::string_view &v) { return v.data(); }),
        std::back_inserter(container)
      );
      container.push_back(nullptr);
      return container;
    }

    /*
      Spawn the subprocess
    */
    template <std::ranges::range Container>
      requires(std::same_as<std::ranges::range_value_t<Container>, std::string_view>)
    void _spawn_subprocess(const std::string_view &command, const Container &arguments) {
      std::vector<const char *> argv_container = _make_argv(arguments);
      // The following const cast is SAFE as the posix API does not modify the container.
      char *const *argv = const_cast<char *const *>(argv_container.data());

      posix_spawn(&_pid, command.data(), &_spawn_action, &_spawn_attributes, argv, nullptr);
    }
  };
}